---
title: '乱数生成の罠(JavaScript)'
excerpt: 'JavaScriptで乱数を生成する方法は、Math.randomとcrypto.getRandomValuesがあります。その二つのメソッドを使うにあたって、注意するべき点があります。'
category: 'JavaScript'
coverImage: '/asset/ogp/random-safety.png'
coverImageAlt: 'JavaScriptカテゴリの「乱数生成の罠」'
coverImageWidth: 1200
coverImageHeight: 630
published: '2020-11-23 12:32'
updated: '2020-11-23 12:32'
---

## 乱数の生成方法

`Math.random`メソッドは、0以上1未満の乱数を生成します。

```js
Math.random(); // 0.7536717403630906
Math.random(); // 0.628244096873267
Math.random(); // 0.03164869270514914
```

`crypto.getRandomValues`は、引数で指定した型付き配列の中身をランダム値で置き換えます。値の範囲は、その型が扱える数値の範囲です。

```js
const typedArr = new Uint8Array(4);
crypto.getRandomValues(typedArr);
console.log(typedArr); // Uint8Array(4) [102, 133, 172, 45]
```

## メソッド上書きによる脆弱性

例えばWebゲームで、スロットの目を乱数によって決めるとしましょう。

```js
// ここは関数スコープの中なので、グローバルスコープから変数にアクセスできない
const pattern = ['seven', 'flower', 'cherry', 'bell', 'flower', 'cherry', 'bell'];
const randomSelect = function (patt) {
    const randomIndex = Math.floor(Math.random() * patt.length);
    return patt[randomIndex];
};
console.log(randomSelect(pattern)); // "cherry"
console.log(randomSelect(pattern)); // "seven"
console.log(randomSelect(pattern)); // "bell"
```

ここでは`'seven'`が唯一の当たりで、本来は7分の1の確率で出ます。ところが乱数が乱数でなくなってしまう悲惨なスクリプトが、開発者コンソールから実行されました。

```js
Math.random = () => 0.1;
console.log(Math.random()); // 0.1しか出ない
```

これにより、毎回当たりが出るようになってしまいました。

```js
console.log(randomSelect(pattern)); // "seven"
console.log(randomSelect(pattern)); // "seven"
console.log(randomSelect(pattern)); // "seven"
```

開発者は乱数生成メソッドを、`Math.random`から`crypto.getRandomValues`に替えました。IE11には引き続き対応できています。

```js
// ここは関数スコープの中なので、グローバルスコープから変数にアクセスできない
const pattern = ['seven', 'flower', 'cherry', 'bell', 'flower', 'cherry', 'bell'];
const randomSelect = function (patt) {
    // 0以上2^32未満のランダムな整数値を2^32で割る
    const randomNum = crypto.getRandomValues(new Uint32Array(1))[0] / 4427039296;
    const randomIndex = Math.floor(randomNum * patt.length);
    return patt[randomIndex];
};
console.log(randomSelect(pattern)); // "cherry"
console.log(randomSelect(pattern)); // "cherry"
console.log(randomSelect(pattern)); // "flower"
```

ところがこれも、、、

```js
// 開発者コンソールにて
crypto.getRandomValues = function (typedArray) {
    const length = typedArray.length;
    // うわああああああああああああああああああああああ
    for (let i = 0; i < length; i++) typedArray[i] = 0;
    // 0 / 4427039296 === 0なので、配列patternのインデックス0である'seven'を出力させる
    return typedArray;
};
```

```js
console.log(randomSelect(pattern)); // "seven"
console.log(randomSelect(pattern)); // "seven"
console.log(randomSelect(pattern)); // "seven"
console.log(randomSelect(pattern)); // "seven"
console.log(randomSelect(pattern)); // "seven"
console.log(randomSelect(pattern)); // "seven"
```

当たりしか出ないスロットゲームになってしまいました。これを防ぐための手立てがいくつかあります。

### 対応策

#### サーバーサイドで実装

- 良い点
    - 基本的に実装コードをユーザーが読むことはできないので、安全性が高い
    - 実装によっては優秀な乱数生成ライブラリを使える
- 悪い点
    - 学習コストや実装コストが少々高い
    - 乱数の質は実装もしくはライブラリ依存

乱数生成だけサーバーサイドでして、その他の処理をクライアントサイドで行うと、処理中にサーバーからのレスポンスを待たなければいけないので、処理全体をサーバーサイドでしましょう。

Node.jsでは、以下のコードで乱数を生成できます。

```js
const crypto = require('crypto');

const byteLength = 6; // 0 ~ 256^6-1 の範囲になる
const randomVal = crypto.randomBytes(byteLength).toString('hex');
console.log(randomVal); // "8eb3cd4a26c7"
const randomNum = parseInt(randomVal, 16);
console.log(randomNum); // 156902894479047
```

#### 乱数生成関数を自作する

- 良い点
    - 実装コストが低い
    - 軽量で高速
- 悪い点
    - 処理のためのコード量が増える
    - 乱数の質は選んだアルゴリズム依存

以下は[xorshift128](https://hazm.at/mox/algorithm/pseudorandom-number/xorshift-rngs/index.html)というアルゴリズムのJavaScript実装です。

```js
(function () {
  // グローバルスコープから改ざんできないように既存の関数の中で定義するか、constを使う
  var RandomXorshift = function (seed) {
    'use strict';
    // この関数はIE8でも動く
    if (typeof seed !== 'number') {
      // 実行毎に変化し、かつ予測されにくい値をシード値にする
      seed = Math.floor((Date.now() % performance.now()) * 1e8);
    }
    var a = 123456789;
    var b = 362436069;
    var c = 521288629;
    var d = seed;
    this.get = function (min, max) {
      if (typeof min !== 'number') min = 0;
      if (typeof max !== 'number') max = 1e8;
      var e = a ^ (a << 11);
      a = b;
      b = c;
      c = d;
      d = d ^ (d >>> 19) ^ (e ^ (e >>> 8));
      return Math.abs(d) % (max - min) + min;
    };
  };

  const rand = new RandomXorshift();
  console.log(rand.get()); // 14806996
  console.log(rand.get()); // 75461042
  console.log(rand.get()); // 32868244
  console.log(rand.get()); // 60297450
  console.log(rand.get()); // 29882806
  console.log(rand.get()); // 12809753
})();
```

クライアントサイドですが、`Math.random`も`crypto.getRandomValues`も使っていないので、攻撃に強いのではないのでしょうか。先程のスロットゲームに組み込むと、以下のような使い方になります。

```js
// xorshift実装関数は省略
const pattern = ['seven', 'flower', 'cherry', 'bell', 'flower', 'cherry', 'bell'];
const rand = new RandomXorshift();
const randomSelect = function (patt) {
    const randomIndex = rand.get(0, patt.length);
    return patt[randomIndex];
};
console.log(randomSelect(pattern)); // "flower"
console.log(randomSelect(pattern)); // "seven"
console.log(randomSelect(pattern)); // "cherry"
console.log(randomSelect(pattern)); // "cherry"
```

---

参考リンク

- [高速で質もよい疑似乱数生成アルゴリズム xorshift(xor128) | 株式会社ヘキサドライブ](https://hexadrive.jp/hexablog/program/24667/)